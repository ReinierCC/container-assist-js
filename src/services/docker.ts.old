/**
 * Docker Service
 */

import { EventEmitter } from 'events';
import { TrivyScanner } from '../infrastructure/external/cli/trivy.js';
import {
  ok,
  fail,
  Result,
  DockerBuildOptions,
  DockerBuildResult,
  DockerScanResult,
  ScanOptions
} from '../contracts/types/index.js';
import type { Logger } from 'pino';
import { DockerAdapterFactory } from '../infrastructure/external/docker/adapters/DockerAdapterFactory.js';
import type { IDockerAdapter } from '../infrastructure/external/docker/interfaces/IDockerAdapter.js';

const DOCKER_TIMEOUTS = {
  SCAN_DEFAULT: 300000     // 5 minutes for vulnerability scanning
} as const;

export interface DockerConfig {
  docker?: any;
  preferredStrategy?: 'dockerode' | 'cli';
  trivy?: any;
}

/**
 * Create a Docker service instance
 */
export async function createDockerService(
  config: DockerConfig,
  logger: Logger
): Promise<DockerService> {
  const service = new DockerService(config, logger);
  await service.initialize();
  return service;
}

export class DockerService {
  private adapter: IDockerAdapter | null = null;
  private trivy: TrivyScanner;
  private logger: Logger;
  private eventEmitter = new EventEmitter();

  constructor(
    private config: DockerConfig,
    logger: Logger
  ) {
    this.logger = logger.child({ service: 'docker' });
    this.trivy = new TrivyScanner(config.trivy || {}, this.logger);
  }

  async initialize(): Promise<Result<void>> {
    try {
      // Get working adapter using the factory
      const adapterResult = await DockerAdapterFactory.getWorkingAdapter(
        this.config.docker || {},
        this.config.preferredStrategy || 'dockerode',
        this.logger
      );

      if (isOk(adapterResult)) {
        this.adapter = adapterResult.data;
        this.logger.info('Docker service initialized successfully');
        return ok(undefined);
      }

      return fail(`Docker initialization failed: ${adapterResult.error}`);
    } catch (error) {
      return fail(`Docker initialization error: ${error}`);
    }
  }

  async buildImage(options: DockerBuildOptions): Promise<Result<DockerBuildResult>> {
    if (!this.adapter) {
      return fail('Docker service not initialized');
    }

    this.logger.info({ dockerfile: options.dockerfile }, 'Building Docker image');

    try {
      const result = await this.adapter.build(options);

      if (isOk(result)) {
        this.logger.info({ imageId: result.data.imageId }, 'Docker build successful');
        return result;
      }

      return result;
    } catch (error) {
      return fail(`Build failed: ${error}`);
    }
  }

  async scanImage(image: string, options?: ScanOptions): Promise<Result<DockerScanResult>> {
    const timeout = options?.timeout || DOCKER_TIMEOUTS.SCAN_DEFAULT;

    this.logger.info({ image, timeout }, 'Scanning Docker image for vulnerabilities');

    try {
      const result = await this.trivy.scanImage(image, { ...options, timeout });

      if (isOk(result)) {
        this.logger.info({
          image,
          vulnerabilities: result.data.summary
        }, 'Scan completed');
      }

      return result;
    } catch (error) {
      return fail(`Scan failed: ${error}`);
    }
  }

  async pushImage(tag: string, registry?: any): Promise<Result<any>> {
    if (!this.adapter) {
      return fail('Docker service not initialized');
    }

    return this.adapter.push(tag, registry);
  }

  async tagImage(imageId: string, tag: string): Promise<Result<void>> {
    if (!this.adapter) {
      return fail('Docker service not initialized');
    }

    return this.adapter.tag(imageId, tag);
  }

  async listImages(): Promise<Result<any[]>> {
    if (!this.adapter) {
      return fail('Docker service not initialized');
    }

    return this.adapter.listImages();
  }

  async imageExists(imageId: string): Promise<Result<boolean>> {
    if (!this.adapter) {
      return fail('Docker service not initialized');
    }

    return this.adapter.imageExists(imageId);
  }

  async removeImage(imageId: string): Promise<Result<void>> {
    if (!this.adapter) {
      return fail('Docker service not initialized');
    }

    return this.adapter.removeImage(imageId);
  }

  async close(): Promise<void> {
    // Cleanup if needed
    this.adapter = null;
  }

  async health(): Promise<Result<{ healthy: boolean }>> {
    if (!this.adapter) {
      return ok({ healthy: false });
    }

    return this.adapter.health();
  }
}

// Re-export types for convenience
export type { DockerBuildOptions, DockerBuildResult, DockerScanResult } from '../contracts/types/index.js';

// Helper to check if result is ok/fail (re-export from contracts)
export { isOk, isFail } from '../contracts/types/index.js';
