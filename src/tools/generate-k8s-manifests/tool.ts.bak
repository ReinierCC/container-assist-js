/**
 * Generate K8s Manifests Tool - Standardized Implementation
 *
 * Generates Kubernetes manifests for application deployment
 * Uses standardized helpers for consistent behavior
 */

import path from 'node:path';
import { promises as fs } from 'node:fs';
import crypto from 'node:crypto';
import { wrapTool } from '@mcp/tools/tool-wrapper';
import { resolveSession } from '@mcp/tools/session-helpers';
import { aiGenerate } from '@mcp/tools/ai-helpers';
import { formatStandardResponse } from '@mcp/tools/response-formatter';
import { reportProgress } from '@mcp/utils/progress-helper';
import { createTimer, type Logger } from '@lib/logger';
import { Success, Failure, type Result, updateWorkflowState } from '../../domain/types';
import { stripFencesAndNoise, isValidKubernetesContent } from '@lib/text-processing';

/**
 * Configuration for Kubernetes manifest generation
 */
export interface GenerateK8sManifestsConfig {
  /** Session identifier for storing results */
  sessionId?: string;
  /** Docker image ID to deploy (optional, defaults to build result) */
  imageId?: string;
  /** Application name (defaults to detected name) */
  appName?: string;
  /** Kubernetes namespace (defaults to 'default') */
  namespace?: string;
  /** Number of replicas (defaults to 1) */
  replicas?: number;
  /** Application port (defaults to detected port) */
  port?: number;
  /** Service type for external access */
  serviceType?: 'ClusterIP' | 'NodePort' | 'LoadBalancer';
  /** Enable ingress controller */
  ingressEnabled?: boolean;
  /** Hostname for ingress routing */
  ingressHost?: string;
  /** Resource requests and limits */
  resources?: {
    requests?: {
      memory: string;
      cpu: string;
    };
    limits?: {
      memory: string;
      cpu: string;
    };
  };
  /** Horizontal pod autoscaling configuration */
  autoscaling?: {
    enabled: boolean;
    minReplicas?: number;
    maxReplicas?: number;
    targetCPU?: number;
  };
  /** Deployment environment (development, staging, production) */
  environment?: string;
  /** Security hardening level */
  securityLevel?: 'standard' | 'strict';
  /** Enable high availability features */
  highAvailability?: boolean;
  /** Enable monitoring/observability */
  monitoring?: boolean;
  /** Include ConfigMap for configuration */
  hasConfig?: boolean;
  hasSecrets?: boolean;
}

/**
 * Result of Kubernetes manifest generation operation
 */
export interface GenerateK8sManifestsResult {
  /** Whether the generation was successful */
  ok: boolean;
  /** Session identifier used for generation */
  sessionId: string;
  /** Generated YAML manifest content */
  manifests: string;
  /** Path where manifests were written */
  path: string;
  /** List of generated Kubernetes resources */
  resources: Array<{
    /** Resource type (Deployment, Service, etc.) */
    kind: string;
    /** Resource name */
    name: string;
    /** Target namespace */
    namespace: string;
  }>;
  /** Optional warnings about the configuration */
  warnings?: string[];
  /** Whether AI was used for generation */
  aiUsed?: boolean;
  /** Generation method used */
  generationMethod?: 'AI' | 'template';
  /** Array of individual manifest objects */
  manifestTypes?: string[];
}

/**
 * Kubernetes resource interface
 */
interface K8sResource {
  apiVersion: string;
  kind: string;
  metadata: {
    name: string;
    namespace: string;
    labels?: Record<string, string>;
    annotations?: Record<string, string>;
  };
  spec: Record<string, unknown>;
}

/**
 * Compute hash for default session ID
 */
function computeHash(input: string): string {
  return crypto.createHash('sha256').update(input).digest('hex').substring(0, 8);
}

/**
 * Generate deployment manifest
 */
function generateDeployment(config: {
  appName: string;
  namespace: string;
  replicas: number;
  image: string;
  port: number;
  resources?: Record<string, unknown>;
}): K8sResource {
  return {
    apiVersion: 'apps/v1',
    kind: 'Deployment',
    metadata: {
      name: config.appName,
      namespace: config.namespace,
      labels: {
        app: config.appName,
      },
    },
    spec: {
      replicas: config.replicas,
      selector: {
        matchLabels: {
          app: config.appName,
        },
      },
      template: {
        metadata: {
          labels: {
            app: config.appName,
          },
        },
        spec: {
          containers: [
            {
              name: config.appName,
              image: config.image,
              ports: [
                {
                  containerPort: config.port,
                },
              ],
              ...(config.resources && { resources: config.resources }),
            },
          ],
        },
      },
    },
  };
}

/**
 * Generate service manifest
 */
function generateService(config: {
  appName: string;
  namespace: string;
  port: number;
  serviceType: string;
}): K8sResource {
  return {
    apiVersion: 'v1',
    kind: 'Service',
    metadata: {
      name: config.appName,
      namespace: config.namespace,
    },
    spec: {
      type: config.serviceType,
      selector: {
        app: config.appName,
      },
      ports: [
        {
          port: config.port,
          targetPort: config.port,
          protocol: 'TCP',
        },
      ],
    },
  };
}

/**
 * Generate ingress manifest
 */
function generateIngress(config: {
  appName: string;
  namespace: string;
  host?: string;
  port: number;
}): K8sResource {
  return {
    apiVersion: 'networking.k8s.io/v1',
    kind: 'Ingress',
    metadata: {
      name: `${config.appName}-ingress`,
      namespace: config.namespace,
      annotations: {
        'kubernetes.io/ingress.class': 'nginx',
      },
    },
    spec: {
      rules: [
        {
          ...(config.host && { host: config.host }),
          http: {
            paths: [
              {
                path: '/',
                pathType: 'Prefix',
                backend: {
                  service: {
                    name: config.appName,
                    port: {
                      number: config.port,
                    },
                  },
                },
              },
            ],
          },
        },
      ],
    },
  };
}

/**
 * Generate HPA manifest
 */
function generateHPA(config: {
  appName: string;
  namespace: string;
  minReplicas: number;
  maxReplicas: number;
  targetCPU: number;
}): K8sResource {
  return {
    apiVersion: 'autoscaling/v2',
    kind: 'HorizontalPodAutoscaler',
    metadata: {
      name: `${config.appName}-hpa`,
      namespace: config.namespace,
    },
    spec: {
      scaleTargetRef: {
        apiVersion: 'apps/v1',
        kind: 'Deployment',
        name: config.appName,
      },
      minReplicas: config.minReplicas,
      maxReplicas: config.maxReplicas,
      metrics: [
        {
          type: 'Resource',
          resource: {
            name: 'cpu',
            target: {
              type: 'Utilization',
              averageUtilization: config.targetCPU,
            },
          },
        },
      ],
    },
  };
}

/**
 * Build prompt arguments for K8s generation
 */
function buildK8sManifestPromptArgs(
  config: GenerateK8sManifestsConfig,
  image: string,
): Record<string, unknown> {
  const {
    appName = 'app',
    namespace = 'default',
    replicas = 1,
    environment = 'production',
    securityLevel = 'standard',
    highAvailability = false,
    port = 8080,
  } = config;

  const resources = config.resources
    ? `CPU: ${config.resources.requests?.cpu || 'not specified'} (request), ${config.resources.limits?.cpu || 'not specified'} (limit); Memory: ${config.resources.requests?.memory || 'not specified'} (request), ${config.resources.limits?.memory || 'not specified'} (limit)`
    : undefined;

  const ports = port ? port.toString() : undefined;
  const manifestTypes = ['Deployment', 'Service'];
  if (config.ingressEnabled) manifestTypes.push('Ingress');
  if (config.autoscaling?.enabled) manifestTypes.push('HorizontalPodAutoscaler');
  if (highAvailability) manifestTypes.push('PodDisruptionBudget');

  return {
    appName,
    imageId: image,
    namespace,
    replicas: replicas.toString(),
    ports,
    environment,
    manifestTypes,
    resources,
    securityLevel,
    highAvailability,
  };
}

/**
 * Generate basic manifests (fallback when AI is unavailable)
 */
function generateBasicManifests(
  config: GenerateK8sManifestsConfig,
  image: string,
): Result<{
  manifests: K8sResource[];
  aiUsed: boolean;
}> {
  const {
    appName = 'app',
    namespace = 'default',
    replicas = 1,
    port = 8080,
    serviceType = 'ClusterIP',
    ingressEnabled = false,
    ingressHost,
    resources,
    autoscaling,
  } = config;

  const manifests: K8sResource[] = [];

  // 1. Deployment
  const deployment = generateDeployment({
    appName,
    namespace,
    replicas,
    image,
    port,
    ...(resources && { resources }),
  });
  manifests.push(deployment);

  // 2. Service
  const service = generateService({
    appName,
    namespace,
    port,
    serviceType,
  });
  manifests.push(service);

  // 3. Ingress (if enabled)
  if (ingressEnabled) {
    const ingress = generateIngress({
      appName,
      namespace,
      ...(ingressHost && { host: ingressHost }),
      port,
    });
    manifests.push(ingress);
  }

  // 4. HPA (if autoscaling enabled)
  if (autoscaling?.enabled) {
    const hpa = generateHPA({
      appName,
      namespace,
      minReplicas: autoscaling.minReplicas ?? replicas,
      maxReplicas: autoscaling.maxReplicas ?? replicas * 3,
      targetCPU: autoscaling.targetCPU ?? 80,
    });
    manifests.push(hpa);
  }

  return Success({ manifests, aiUsed: false });
}

/**
 * Parse K8s manifests from AI response
 */
function parseK8sManifestsFromAI(aiResponse: string): K8sResource[] {
  try {
    const yamlMatch = aiResponse.match(/```(?:yaml|yml)?\n([\s\S]*?)\n```/i);
    const yamlContent = yamlMatch?.[1] ? yamlMatch[1] : aiResponse;

    const documents = yamlContent.split(/^---\s*$/m).filter((doc) => doc.trim());
    const manifests: K8sResource[] = [];

    for (const doc of documents) {
      const trimmedDoc = doc.trim();
      if (!trimmedDoc) continue;

      try {
        // Simple YAML to JSON conversion for basic structures
        const manifest = parseYAMLtoJSON(trimmedDoc);
        if (manifest && typeof manifest === 'object' && manifest.kind) {
          manifests.push(manifest as K8sResource);
        }
      } catch {
        continue;
      }
    }

    return manifests;
  } catch {
    return [];
  }
}

/**
 * Simple YAML to JSON parser for basic K8s manifests
 */
function parseYAMLtoJSON(yamlString: string): Partial<K8sResource> | null {
  try {
    const lines = yamlString.split('\n');
    const result: Record<string, unknown> = {};
    let currentObj = result;

    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;

      const colonIndex = trimmed.indexOf(':');
      if (colonIndex === -1) continue;

      const key = trimmed.substring(0, colonIndex).trim();
      const value = trimmed.substring(colonIndex + 1).trim();

      if (value && value !== '') {
        if (value.startsWith('"') && value.endsWith('"')) {
          currentObj[key] = value.slice(1, -1);
        } else if (value === 'true' || value === 'false') {
          currentObj[key] = value === 'true';
        } else if (!isNaN(Number(value))) {
          currentObj[key] = Number(value);
        } else {
          currentObj[key] = value;
        }
      } else {
        const newObj: Record<string, unknown> = {};
        currentObj[key] = newObj;
        currentObj = newObj;
      }
    }

    return result.kind ? (result as Partial<K8sResource>) : null;
  } catch {
    return null;
  }
}

/**
 * Generate warnings based on configuration
 */
function generateWarnings(config: GenerateK8sManifestsConfig): string[] {
  const warnings: string[] = [];

  if ((config.replicas ?? 1) === 1) {
    warnings.push('Single replica configuration - consider increasing for production');
  }

  if (!config.resources?.limits) {
    warnings.push('No resource limits specified - may cause resource contention');
  }

  if (config.ingressEnabled && !config.ingressHost) {
    warnings.push('Ingress enabled but no host specified');
  }

  if (config.serviceType === 'LoadBalancer') {
    warnings.push('LoadBalancer service type may incur cloud provider costs');
  }

  return warnings;
}

/**
 * Generate Kubernetes manifests - Standardized implementation
 */
export const generateK8sManifestsTool = wrapTool(
  'generate-k8s-manifests',
  async (params: GenerateK8sManifestsConfig, context, logger) => {
    const timer = createTimer(logger, 'generate-k8s-manifests');

    try {
      const { appName = 'app', namespace = 'default' } = params;

      // Progress: Analyzing
      if (context && 'progressReporter' in context && context.progressReporter) {
        await reportProgress(context.progressReporter, 'analyzing', 'Preparing K8s generation');
      }

      // Resolve session with optional sessionId
      const sessionResult = await resolveSession(logger, context, {
        sessionId: params.sessionId ?? undefined,
        defaultIdHint: computeHash(`k8s-${appName}`),
        createIfNotExists: true,
      });

      if (!sessionResult.ok) {
        return sessionResult;
      }

      const session = sessionResult.value;
      const sessionData = session as any;

      // Get build result from session for image tag
      const buildResult = sessionData?.build_result || sessionData?.workflow_state?.build_result;
      const image = params.imageId || buildResult?.tags?.[0] || `${appName}:latest`;

      // Progress: Processing
      if (context && 'progressReporter' in context && context.progressReporter) {
        await reportProgress(context.progressReporter, 'processing', 'Generating manifests');
      }

      // Generate K8s manifests with AI or fallback
      const result = await aiGenerate(logger, context as any, {
        promptName: 'generate-k8s-manifests',
        promptArgs: buildK8sManifestPromptArgs(params, image),
        expectation: 'kubernetes-manifests',
        maxRetries: 2,
        processResponse: async (response: string) => {
          const cleaned = stripFencesAndNoise(response);

          if (!isValidKubernetesContent(cleaned)) {
            throw new Error('Invalid Kubernetes content');
          }

          const manifests = parseK8sManifestsFromAI(cleaned);
          if (manifests.length === 0) {
            throw new Error('No valid manifests parsed from AI response');
          }

          return Success({
            manifests,
            aiUsed: true,
          });
        },
      }).catch(() => {
        // Fallback to basic generation
        return generateBasicManifests(params, image);
      });

      if (!result.ok) {
        // Use fallback if AI failed
        const fallbackResult = generateBasicManifests(params, image);
        if (!fallbackResult.ok) {
          return fallbackResult;
        }
        result.value = fallbackResult.value;
      }

      // Progress: Finalizing
      if (context && 'progressReporter' in context && context.progressReporter) {
        await reportProgress(context.progressReporter, 'finalizing', 'Writing manifests');
      }

      // Build resource list
      const resourceList: Array<{ kind: string; name: string; namespace: string }> = [];
      const manifests = (result.value as any).manifests || [];

      for (const manifest of manifests) {
        if (manifest.kind && manifest.metadata?.name) {
          resourceList.push({
            kind: manifest.kind,
            name: manifest.metadata.name,
            namespace: manifest.metadata.namespace || namespace,
          });
        }
      }

      // Convert manifests to YAML string
      const yaml = manifests.map((m: K8sResource) => JSON.stringify(m, null, 2)).join('\n---\n');

      // Write manifests to disk
      const repoPath =
        sessionData?.metadata?.repo_path || sessionData?.workflow_state?.metadata?.repo_path || '.';
      const outputPath = path.join(repoPath, 'k8s');
      await fs.mkdir(outputPath, { recursive: true });
      const manifestPath = path.join(outputPath, 'manifests.yaml');
      await fs.writeFile(manifestPath, yaml, 'utf-8');

      // Generate warnings
      const warnings = generateWarnings(params);

      // Update session with K8s manifests
      const currentWorkflowState = sessionData?.workflow_state || {};
      const updatedWorkflowState = updateWorkflowState(currentWorkflowState, {
        k8s_result: {
          manifests: resourceList,
          replicas: params.replicas ?? 1,
          ...(params.resources && { resources: params.resources }),
          output_path: manifestPath,
        },
        completed_steps: [
          ...(currentWorkflowState?.completed_steps ?? []),
          'generate-k8s-manifests',
        ],
        metadata: {
          ...(currentWorkflowState?.metadata ?? {}),
          k8s_warnings: warnings,
          ai_enhancement_used: (result.value as any).aiUsed,
        },
      });

      // Update session through manager if available
      if (session && typeof session === 'object' && 'id' in session) {
        const sessionManager = (context as any)?.sessionManager;
        if (sessionManager) {
          await sessionManager.update(session.id, {
            workflow_state: updatedWorkflowState,
          });
        }
      }

      // Progress: Complete
      if (context && 'progressReporter' in context && context.progressReporter) {
        await reportProgress(context.progressReporter, 'complete', 'K8s manifests generated');
      }

      timer.end({ resourceCount: resourceList.length });

      // Return standardized response
      const sessionId =
        typeof session === 'object' && 'id' in session ? session.id : params.sessionId || 'default';
      return formatStandardResponse(
        Success({
          manifests: yaml,
          path: manifestPath,
          resources: resourceList,
          ...(warnings.length > 0 && { warnings }),
          aiUsed: (result.value as any).aiUsed,
          generationMethod: (result.value as any).aiUsed ? 'AI' : 'template',
        }),
        sessionId,
      );
    } catch (error) {
      timer.error(error);
      logger.error({ error }, 'K8s manifests generation failed');
      return Failure(error instanceof Error ? error.message : String(error));
    }
  },
);

/**
 * Legacy function export for backward compatibility
 */
export async function generateK8sManifests(
  config: GenerateK8sManifestsConfig,
  logger: Logger,
  context?: any,
): Promise<Result<GenerateK8sManifestsResult>> {
  return (generateK8sManifestsTool as any)(config, context, logger);
}
