#!/usr/bin/env node

import { readFileSync, writeFileSync, mkdirSync, copyFileSync, readdirSync, statSync } from 'fs';
import { join, dirname, relative } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const rootDir = join(__dirname, '..');
const srcDir = join(rootDir, 'src');
const distDir = join(rootDir, 'dist');

console.log('üèóÔ∏è  Building Container Kit MCP for distribution...');

/**
 * Simple JavaScript "compilation" - copy files and update imports
 * Since we're using pure JavaScript, this is mainly about:
 * 1. Copying source files to dist/
 * 2. Updating import paths to be explicit (.js extensions)
 * 3. Creating the main index.js entry point
 * 4. Creating the binary entry point
 */
class Builder {
  
  constructor() {
    this.copiedFiles = new Set();
  }
  
  async build() {
    console.log('üìÅ Creating dist directory structure...');
    this.createDistStructure();
    
    console.log('üìÇ Copying source files...');
    this.copySourceFiles();
    
    console.log('üìù Creating main entry point...');
    this.createMainEntryPoint();
    
    console.log('üîß Creating binary entry point...');
    this.createBinaryEntryPoint();
    
    console.log('üìã Creating type definitions...');
    this.createTypeDefinitions();
    
    console.log('‚úÖ Build complete!');
    console.log(`   Source files: ${this.copiedFiles.size}`);
    console.log(`   Distribution: ${distDir}`);
  }
  
  createDistStructure() {
    const directories = [
      'bin',
      'service/tools/handlers',
      'service/config',
      'domain/types',
      'domain/workflow',
      'infrastructure/ai/prompts/templates',
      'infrastructure/docker',
      'infrastructure/cli',
      'infrastructure/core',
      'infrastructure/messaging',
      'infrastructure/java',
      'shared'
    ];
    
    directories.forEach(dir => {
      mkdirSync(join(distDir, dir), { recursive: true });
    });
  }
  
  copySourceFiles() {
    this.copyDirectory(srcDir, distDir);
    
    // Copy prompt templates
    const templatesDir = join(srcDir, 'infrastructure/ai/prompts/templates');
    const destTemplatesDir = join(distDir, 'infrastructure/ai/prompts/templates');
    
    if (this.exists(templatesDir)) {
      this.copyDirectory(templatesDir, destTemplatesDir);
    }
  }
  
  copyDirectory(src, dest) {
    if (!this.exists(src)) return;
    
    const items = readdirSync(src);
    
    items.forEach(item => {
      const srcPath = join(src, item);
      const destPath = join(dest, item);
      const stat = statSync(srcPath);
      
      if (stat.isDirectory()) {
        mkdirSync(destPath, { recursive: true });
        this.copyDirectory(srcPath, destPath);
      } else if (item.endsWith('.js') || item.endsWith('.yaml') || item.endsWith('.yml')) {
        this.copyFile(srcPath, destPath);
        this.copiedFiles.add(relative(rootDir, destPath));
      }
    });
  }
  
  copyFile(src, dest) {
    // For JavaScript files, we could process imports here if needed
    // For now, just copy directly since our imports should work as-is
    copyFileSync(src, dest);
  }
  
  exists(path) {
    try {
      statSync(path);
      return true;
    } catch {
      return false;
    }
  }
  
  createMainEntryPoint() {
    const entryContent = `// Container Kit MCP - Main Entry Point
// Auto-generated by build script

export { Server } from '@modelcontextprotocol/sdk/server/index.js';
export { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

// Core components
export { Dependencies } from './service/dependencies.js';
export { ToolRegistry } from './service/tools/registry.js';
export { Config } from './service/config/config.js';

// Domain types
export * from './domain/types/result.js';
export * from './domain/types/errors.js';

// Session management (when implemented)
// export { SessionService } from './service/session/manager.js';

// Tool handlers - individual exports for flexible usage
export { analyzeRepositoryHandler } from './service/tools/handlers/analyze-enhanced.js';
export { generateDockerfileHandler } from './service/tools/handlers/dockerfile-generation-enhanced.js';
export { buildImageHandler } from './service/tools/handlers/build-image-enhanced.js';
export { scanImageHandler } from './service/tools/handlers/scan-image-enhanced.js';
export { tagPushImageHandler } from './service/tools/handlers/tag-push-enhanced.js';
export { generateK8sManifestsHandler } from './service/tools/handlers/k8s-generation-enhanced.js';
export { k8sOperationsHandler } from './service/tools/handlers/k8s-enhanced.js';
export { workflowOrchestrationHandler } from './service/tools/handlers/orchestration-enhanced.js';
export { workflowStatusHandler } from './service/tools/handlers/workflow.js';
export { utilityToolsHandler } from './service/tools/handlers/utility.js';

// Infrastructure
export { createLogger } from './infrastructure/core/logger.js';
export { MCPSampler } from './infrastructure/ai/mcp-sampler.js';
export { MockSampler } from './infrastructure/ai/mock-sampler.js';

// Version info
export const version = '2.0.0-beta.1';
export const name = 'container-kit-mcp';
`;

    writeFileSync(join(distDir, 'index.js'), entryContent);
  }
  
  createBinaryEntryPoint() {
    // Copy the main server.js to dist/bin/server.js
    const serverContent = readFileSync(join(rootDir, 'server.js'), 'utf8');
    
    // Update imports to point to the dist directory
    const updatedContent = serverContent
      .replace(/from '\.\/src\//g, "from '../")
      .replace(/import process from 'process'/, "import process from 'process'");
      
    writeFileSync(join(distDir, 'bin/server.js'), updatedContent);
    
    // Make it executable (will be handled by npm)
    console.log('   Binary created: dist/bin/server.js');
  }
  
  createTypeDefinitions() {
    // Create basic TypeScript definition files for key exports
    const mainDts = `// Container Kit MCP Type Definitions
// Auto-generated by build script

export interface ToolResult<T = any> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  timestamp: string;
  metadata?: Record<string, unknown>;
}

export interface ToolHandler<TInput = any, TOutput = any> {
  (input: TInput): Promise<ToolResult<TOutput>>;
}

export interface SessionData {
  id: string;
  created_at: string;
  updated_at: string;
  status?: 'active' | 'completed' | 'failed' | 'expired';
  workflowState?: Record<string, any>;
}

export interface MCPServerConfig {
  name: string;
  version: string;
}

// Tool handler exports
export declare const analyzeRepositoryHandler: ToolHandler;
export declare const generateDockerfileHandler: ToolHandler;
export declare const buildImageHandler: ToolHandler;
export declare const scanImageHandler: ToolHandler;
export declare const tagPushImageHandler: ToolHandler;
export declare const generateK8sManifestsHandler: ToolHandler;
export declare const k8sOperationsHandler: ToolHandler;
export declare const workflowOrchestrationHandler: ToolHandler;
export declare const workflowStatusHandler: ToolHandler;
export declare const utilityToolsHandler: ToolHandler;

// Core components
export declare class Dependencies {
  constructor(options: any);
  initialize(): Promise<void>;
  cleanup(): Promise<void>;
}

export declare class ToolRegistry {
  constructor(server: any, dependencies: Dependencies);
  registerAllTools(): Promise<void>;
  getRegisteredTools(): string[];
}

export declare class Config {
  constructor();
}

export declare function createLogger(config: Config): any;

export declare const version: string;
export declare const name: string;
`;

    writeFileSync(join(distDir, 'index.d.ts'), mainDts);
    
    console.log('   Type definitions created: dist/index.d.ts');
  }
}

// Run the build
const builder = new Builder();
builder.build().catch(error => {
  console.error('‚ùå Build failed:', error);
  process.exit(1);
});